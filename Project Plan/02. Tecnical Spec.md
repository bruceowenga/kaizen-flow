# Technical Design Document: TaskFlow

**Version:** 1.0  
**Last Updated:** February 5, 2026  
**Author:** Bruce Mbudi  
**Status:** Draft  
**Related Documents:** PRD v1.0

---

## Table of Contents

1. [System Overview](#1-system-overview)
2. [Architecture](#2-architecture)
3. [Data Model](#3-data-model)
4. [Component Design](#4-component-design)
5. [API Specifications](#5-api-specifications)
6. [Security & Privacy](#6-security-privacy)
7. [Performance & Scalability](#7-performance-scalability)
8. [Deployment & Operations](#8-deployment-operations)
9. [Testing Strategy](#9-testing-strategy)
10. [Development Environment](#10-development-environment)

---

## 1. System Overview

### 1.1 High-Level Architecture

```
┌─────────────────────────────────────────────────────────────┐
│                      Presentation Layer                      │
├──────────────────┬──────────────────┬──────────────────────┤
│   Desktop App    │    Mobile App    │   CLI/MCP Server    │
│   (Tauri + React)│    (Flutter)     │     (Python)        │
└────────┬─────────┴────────┬─────────┴──────────┬───────────┘
         │                  │                     │
         └──────────────────┼─────────────────────┘
                            │
┌───────────────────────────▼─────────────────────────────────┐
│                      Business Logic Layer                    │
├──────────────────┬──────────────────┬──────────────────────┤
│  Task Manager    │  Review Engine   │   Sync Manager      │
│  Context Engine  │  NLP Parser      │   Analytics         │
└────────┬─────────┴────────┬─────────┴──────────┬───────────┘
         │                  │                     │
         └──────────────────┼─────────────────────┘
                            │
┌───────────────────────────▼─────────────────────────────────┐
│                       Data Layer                             │
├──────────────────┬──────────────────┬──────────────────────┤
│   SQLite DB      │   Git Sync       │   File System       │
│   (Local)        │   (Remote)       │   (Exports/Logs)    │
└──────────────────┴──────────────────┴──────────────────────┘
```

### 1.2 Technology Stack

#### Desktop Application
- **Framework:** Tauri 1.5.4
  - **Rationale:** Smaller binary size than Electron (~3MB vs ~100MB), better performance, Rust security
- **Frontend:** React 18.2 + TypeScript 5.3
- **State Management:** Zustand 4.5
- **UI Components:** Custom components + Radix UI primitives
- **Styling:** Tailwind CSS 3.4
- **Build Tool:** Vite 5.0
- **Database Access:** Tauri SQL plugin (rusqlite wrapper)

#### Mobile Application
- **Framework:** Flutter 3.16.5
- **Language:** Dart 3.2
- **State Management:** Riverpod 2.4
- **Database:** sqflite 2.3.2
- **Local Storage:** shared_preferences 2.2.2
- **Platform Channels:** Custom implementations for widgets

#### Backend Services
- **MCP Server:** Python 3.11+ with official MCP SDK
- **Sync Server (Optional):** FastAPI 0.109 + PostgreSQL 15
- **Task Queue:** Python asyncio (no external dependencies for MVP)

#### Development Tools
- **Version Control:** Git 2.43+
- **CI/CD:** GitHub Actions
- **Testing:** 
  - Desktop: Vitest + React Testing Library
  - Mobile: Flutter test framework
  - Backend: pytest 8.0
- **Documentation:** TypeDoc, rustdoc, dartdoc

---

## 2. Architecture

### 2.1 Desktop Application Architecture

```
┌─────────────────────────────────────────────────────────────┐
│                        Tauri App                             │
│                                                              │
│  ┌────────────────────────────────────────────────────┐    │
│  │              React Frontend (WebView)              │    │
│  │                                                     │    │
│  │  ┌──────────────┐  ┌──────────────┐  ┌─────────┐ │    │
│  │  │   Dashboard  │  │Quick Capture │  │ Review  │ │    │
│  │  │   Widget     │  │    Overlay   │  │  Flow   │ │    │
│  │  └──────┬───────┘  └──────┬───────┘  └────┬────┘ │    │
│  │         │                  │                │      │    │
│  │         └──────────────────┼────────────────┘      │    │
│  │                            │                       │    │
│  │  ┌─────────────────────────▼─────────────────────┐│    │
│  │  │          Zustand Store (State)                ││    │
│  │  │  - tasks[]                                    ││    │
│  │  │  - currentContext                             ││    │
│  │  │  - settings                                   ││    │
│  │  │  - syncStatus                                 ││    │
│  │  └────────────────────┬──────────────────────────┘│    │
│  │                       │                            │    │
│  │                       │ Tauri Commands             │    │
│  └───────────────────────┼────────────────────────────┘    │
│                          │                                  │
│  ┌───────────────────────▼────────────────────────────┐    │
│  │              Rust Backend (Tauri Core)             │    │
│  │                                                     │    │
│  │  ┌──────────────┐  ┌──────────────┐  ┌─────────┐ │    │
│  │  │   Database   │  │   Global     │  │  File   │ │    │
│  │  │   Manager    │  │   Hotkey     │  │ Watcher │ │    │
│  │  └──────┬───────┘  └──────┬───────┘  └────┬────┘ │    │
│  │         │                  │                │      │    │
│  │  ┌──────▼──────────────────▼────────────────▼────┐│    │
│  │  │           System Integration Layer            ││    │
│  │  │  - Window management                          ││    │
│  │  │  - Tray icon                                  ││    │
│  │  │  - Notifications                              ││    │
│  │  │  - File system access                         ││    │
│  │  └────────────────────┬──────────────────────────┘│    │
│  └────────────────────────┼───────────────────────────┘    │
│                           │                                 │
│  ┌────────────────────────▼───────────────────────────┐    │
│  │              SQLite Database                       │    │
│  │              (~/.local/share/taskflow/)            │    │
│  └────────────────────────────────────────────────────┘    │
└─────────────────────────────────────────────────────────────┘
```

### 2.2 Mobile Application Architecture

```
┌─────────────────────────────────────────────────────────────┐
│                      Flutter App                             │
│                                                              │
│  ┌────────────────────────────────────────────────────┐    │
│  │                   UI Layer                         │    │
│  │                                                     │    │
│  │  ┌──────────┐  ┌──────────┐  ┌──────────────────┐│    │
│  │  │Dashboard │  │Quick Add │  │  Home Widget     ││    │
│  │  │  Screen  │  │  Widget  │  │  (Platform Ch.)  ││    │
│  │  └────┬─────┘  └────┬─────┘  └────┬─────────────┘│    │
│  │       │             │              │               │    │
│  │       └─────────────┼──────────────┘               │    │
│  │                     │                              │    │
│  │  ┌──────────────────▼──────────────────────────┐  │    │
│  │  │         Riverpod Providers                  │  │    │
│  │  │  - taskProvider                             │  │    │
│  │  │  - contextProvider                          │  │    │
│  │  │  - syncProvider                             │  │    │
│  │  └──────────────────┬──────────────────────────┘  │    │
│  └────────────────────┼─────────────────────────────┘    │
│                       │                                    │
│  ┌────────────────────▼─────────────────────────────┐    │
│  │              Business Logic Layer                │    │
│  │                                                   │    │
│  │  ┌──────────────┐  ┌──────────────┐  ┌────────┐│    │
│  │  │ TaskService  │  │ SyncService  │  │Context ││    │
│  │  │              │  │              │  │Detector││    │
│  │  └──────┬───────┘  └──────┬───────┘  └───┬────┘│    │
│  │         │                  │               │     │    │
│  │  ┌──────▼──────────────────▼───────────────▼───┐│    │
│  │  │           Repository Layer                  ││    │
│  │  │  - TaskRepository                           ││    │
│  │  │  - SettingsRepository                       ││    │
│  │  └──────────────────┬──────────────────────────┘│    │
│  └────────────────────┼─────────────────────────────┘    │
│                       │                                    │
│  ┌────────────────────▼─────────────────────────────┐    │
│  │        sqflite Database (Local SQLite)           │    │
│  └──────────────────────────────────────────────────┘    │
│                                                            │
│  ┌────────────────────────────────────────────────────┐  │
│  │         Platform Channels (Native Code)            │  │
│  │  - iOS: Swift (WidgetKit, Intents)                 │  │
│  │  - Android: Kotlin (AppWidget, WorkManager)        │  │
│  └────────────────────────────────────────────────────┘  │
└─────────────────────────────────────────────────────────────┘
```

### 2.3 Sync Architecture

```
┌──────────────────┐           ┌──────────────────┐
│  Desktop App     │           │   Mobile App     │
│                  │           │                  │
│  ┌────────────┐  │           │  ┌────────────┐ │
│  │   SQLite   │  │           │  │   SQLite   │ │
│  └─────┬──────┘  │           │  └─────┬──────┘ │
│        │         │           │        │        │
│  ┌─────▼──────┐  │           │  ┌─────▼──────┐ │
│  │Git Client  │  │           │  │Git Client  │ │
│  └─────┬──────┘  │           │  └─────┬──────┘ │
└────────┼─────────┘           └────────┼────────┘
         │                              │
         │  Push/Pull                   │  Push/Pull
         │                              │
         └──────────────┬───────────────┘
                        │
         ┌──────────────▼───────────────┐
         │      Git Repository          │
         │      (Homelab Server)        │
         │                              │
         │  ┌────────────────────────┐  │
         │  │  taskflow.db           │  │
         │  │  .git/                 │  │
         │  │  conflict-resolution/  │  │
         │  └────────────────────────┘  │
         └──────────────────────────────┘
                        │
                        │  Optional
         ┌──────────────▼───────────────┐
         │   Sync Server (FastAPI)      │
         │   - Conflict resolution      │
         │   - Shared lists             │
         │   - Real-time notifications  │
         └──────────────────────────────┘
```

### 2.4 MCP Server Architecture

```
┌─────────────────────────────────────────────────────────────┐
│                     Claude Code / Desktop                    │
└──────────────────────────┬──────────────────────────────────┘
                           │ stdio
┌──────────────────────────▼──────────────────────────────────┐
│                   MCP Server (Python)                        │
│                                                              │
│  ┌────────────────────────────────────────────────────┐    │
│  │              MCP Tool Handlers                     │    │
│  │                                                     │    │
│  │  task_add()     task_complete()    task_list()    │    │
│  │  task_current() task_defer()       task_delete()  │    │
│  └────────────────────┬───────────────────────────────┘    │
│                       │                                      │
│  ┌────────────────────▼───────────────────────────────┐    │
│  │           Business Logic Layer                     │    │
│  │  - Task validation                                 │    │
│  │  - Context inference                               │    │
│  │  - Natural language parsing                        │    │
│  └────────────────────┬───────────────────────────────┘    │
│                       │                                      │
│  ┌────────────────────▼───────────────────────────────┐    │
│  │        Shared SQLite Database Access               │    │
│  │        (Read/Write to main app database)           │    │
│  └────────────────────────────────────────────────────┘    │
└─────────────────────────────────────────────────────────────┘
                           │
┌──────────────────────────▼──────────────────────────────────┐
│              SQLite Database (Shared)                        │
│              ~/.local/share/taskflow/taskflow.db             │
└─────────────────────────────────────────────────────────────┘
```

---

## 3. Data Model

### 3.1 Database Schema

```sql
-- Enable foreign key support
PRAGMA foreign_keys = ON;

-- Database version tracking
CREATE TABLE schema_version (
    version INTEGER PRIMARY KEY,
    applied_at INTEGER NOT NULL DEFAULT (strftime('%s', 'now'))
);

INSERT INTO schema_version (version) VALUES (1);

-- Main tasks table
CREATE TABLE tasks (
    id TEXT PRIMARY KEY DEFAULT (lower(hex(randomblob(16)))),
    title TEXT NOT NULL CHECK(length(title) > 0 AND length(title) <= 500),
    status TEXT NOT NULL DEFAULT 'next' 
        CHECK(status IN ('now', 'next', 'waiting', 'scheduled', 'someday', 'done', 'deleted')),
    
    -- Timestamps (Unix epoch in seconds)
    created_at INTEGER NOT NULL DEFAULT (strftime('%s', 'now')),
    updated_at INTEGER NOT NULL DEFAULT (strftime('%s', 'now')),
    completed_at INTEGER,
    deleted_at INTEGER,
    scheduled_for INTEGER,
    
    -- Organization
    context TEXT DEFAULT 'personal' 
        CHECK(context IN ('work', 'personal', 'infrastructure', 'development', 'communication')),
    priority INTEGER DEFAULT 0 CHECK(priority >= 0 AND priority <= 4),
    
    -- Content
    notes TEXT,
    tags TEXT, -- JSON array: ["urgent", "meeting"]
    
    -- Relationships
    parent_id TEXT,
    
    -- Time tracking
    time_spent_seconds INTEGER DEFAULT 0 CHECK(time_spent_seconds >= 0),
    started_at INTEGER,
    
    -- Metadata
    source TEXT DEFAULT 'manual' 
        CHECK(source IN ('manual', 'desktop_hotkey', 'mobile_widget', 'email', 'api', 'mcp', 'monitoring')),
    device_id TEXT, -- Device that created the task
    
    -- Sync metadata
    sync_version INTEGER DEFAULT 1,
    last_synced_at INTEGER,
    conflict_resolution TEXT, -- JSON object for conflict data
    
    -- Natural language parsing metadata
    original_input TEXT, -- Original text before parsing
    parsed_metadata TEXT, -- JSON object with parsing details
    
    FOREIGN KEY(parent_id) REFERENCES tasks(id) ON DELETE CASCADE
);

-- Indexes for common queries
CREATE INDEX idx_tasks_status ON tasks(status) WHERE deleted_at IS NULL;
CREATE INDEX idx_tasks_context ON tasks(context) WHERE deleted_at IS NULL;
CREATE INDEX idx_tasks_scheduled ON tasks(scheduled_for) WHERE scheduled_for IS NOT NULL;
CREATE INDEX idx_tasks_created ON tasks(created_at);
CREATE INDEX idx_tasks_updated ON tasks(updated_at);
CREATE INDEX idx_tasks_parent ON tasks(parent_id) WHERE parent_id IS NOT NULL;

-- Trigger to update updated_at timestamp
CREATE TRIGGER tasks_updated_at 
AFTER UPDATE ON tasks
BEGIN
    UPDATE tasks SET updated_at = strftime('%s', 'now') WHERE id = NEW.id;
END;

-- Trigger to enforce one NOW task rule
CREATE TRIGGER enforce_one_now_task
BEFORE UPDATE ON tasks
WHEN NEW.status = 'now' AND OLD.status != 'now'
BEGIN
    UPDATE tasks 
    SET status = 'next', updated_at = strftime('%s', 'now')
    WHERE status = 'now' AND id != NEW.id;
END;

-- Weekly reviews table
CREATE TABLE reviews (
    id TEXT PRIMARY KEY DEFAULT (lower(hex(randomblob(16)))),
    started_at INTEGER NOT NULL DEFAULT (strftime('%s', 'now')),
    completed_at INTEGER,
    
    -- Statistics
    tasks_reviewed INTEGER DEFAULT 0,
    tasks_completed INTEGER DEFAULT 0,
    tasks_deferred INTEGER DEFAULT 0,
    tasks_scheduled INTEGER DEFAULT 0,
    tasks_deleted INTEGER DEFAULT 0,
    tasks_someday INTEGER DEFAULT 0,
    
    duration_seconds INTEGER,
    
    -- Metadata
    review_type TEXT DEFAULT 'weekly' CHECK(review_type IN ('weekly', 'emergency', 'manual')),
    device_id TEXT,
    notes TEXT
);

CREATE INDEX idx_reviews_started ON reviews(started_at);
CREATE INDEX idx_reviews_completed ON reviews(completed_at) WHERE completed_at IS NOT NULL;

-- Review task mapping (what was reviewed)
CREATE TABLE review_tasks (
    review_id TEXT NOT NULL,
    task_id TEXT NOT NULL,
    action TEXT NOT NULL CHECK(action IN ('completed', 'deferred', 'scheduled', 'deleted', 'someday')),
    timestamp INTEGER NOT NULL DEFAULT (strftime('%s', 'now')),
    
    PRIMARY KEY (review_id, task_id),
    FOREIGN KEY(review_id) REFERENCES reviews(id) ON DELETE CASCADE,
    FOREIGN KEY(task_id) REFERENCES tasks(id) ON DELETE CASCADE
);

-- Context sessions (for automatic context detection)
CREATE TABLE context_sessions (
    id TEXT PRIMARY KEY DEFAULT (lower(hex(randomblob(16)))),
    context TEXT NOT NULL,
    started_at INTEGER NOT NULL DEFAULT (strftime('%s', 'now')),
    ended_at INTEGER,
    
    -- Detection metadata
    detection_method TEXT CHECK(detection_method IN ('time', 'location', 'activity', 'manual')),
    detection_data TEXT, -- JSON: {"wifi": "HomeSSID", "hour": 14}
    
    device_id TEXT
);

CREATE INDEX idx_context_sessions_started ON context_sessions(started_at);

-- Sync log for debugging and conflict resolution
CREATE TABLE sync_log (
    id TEXT PRIMARY KEY DEFAULT (lower(hex(randomblob(16)))),
    timestamp INTEGER NOT NULL DEFAULT (strftime('%s', 'now')),
    operation TEXT NOT NULL CHECK(operation IN ('push', 'pull', 'conflict', 'merge')),
    status TEXT NOT NULL CHECK(status IN ('success', 'failure', 'partial')),
    
    -- Details
    tasks_pushed INTEGER DEFAULT 0,
    tasks_pulled INTEGER DEFAULT 0,
    conflicts_detected INTEGER DEFAULT 0,
    conflicts_resolved INTEGER DEFAULT 0,
    
    error_message TEXT,
    details TEXT, -- JSON object with full sync details
    
    device_id TEXT
);

CREATE INDEX idx_sync_log_timestamp ON sync_log(timestamp);
CREATE INDEX idx_sync_log_status ON sync_log(status) WHERE status != 'success';

-- Application settings
CREATE TABLE settings (
    key TEXT PRIMARY KEY,
    value TEXT NOT NULL,
    type TEXT NOT NULL CHECK(type IN ('string', 'integer', 'boolean', 'json')),
    updated_at INTEGER NOT NULL DEFAULT (strftime('%s', 'now'))
);

-- Default settings
INSERT INTO settings (key, value, type) VALUES
    ('theme', 'system', 'string'),
    ('review_day', '0', 'integer'), -- 0 = Sunday
    ('review_time', '20:00', 'string'),
    ('enable_notifications', 'true', 'boolean'),
    ('sync_enabled', 'true', 'boolean'),
    ('sync_interval_minutes', '5', 'integer'),
    ('sync_remote_url', '', 'string'),
    ('context_detection_enabled', 'true', 'boolean'),
    ('hotkey_quick_capture', 'CommandOrControl+Shift+Space', 'string'),
    ('device_id', lower(hex(randomblob(16))), 'string'),
    ('analytics_enabled', 'false', 'boolean');

-- Analytics events (opt-in only)
CREATE TABLE analytics_events (
    id TEXT PRIMARY KEY DEFAULT (lower(hex(randomblob(16)))),
    event_type TEXT NOT NULL,
    event_data TEXT, -- JSON
    timestamp INTEGER NOT NULL DEFAULT (strftime('%s', 'now')),
    session_id TEXT
);

CREATE INDEX idx_analytics_timestamp ON analytics_events(timestamp);
CREATE INDEX idx_analytics_type ON analytics_events(event_type);

-- Time tracking sessions
CREATE TABLE time_sessions (
    id TEXT PRIMARY KEY DEFAULT (lower(hex(randomblob(16)))),
    task_id TEXT NOT NULL,
    started_at INTEGER NOT NULL DEFAULT (strftime('%s', 'now')),
    ended_at INTEGER,
    duration_seconds INTEGER,
    
    -- Automatic pauses (idle detection)
    pause_count INTEGER DEFAULT 0,
    total_pause_seconds INTEGER DEFAULT 0,
    
    device_id TEXT,
    
    FOREIGN KEY(task_id) REFERENCES tasks(id) ON DELETE CASCADE
);

CREATE INDEX idx_time_sessions_task ON time_sessions(task_id);
CREATE INDEX idx_time_sessions_started ON time_sessions(started_at);

-- Trigger to calculate duration when session ends
CREATE TRIGGER time_session_duration
AFTER UPDATE ON time_sessions
WHEN NEW.ended_at IS NOT NULL AND OLD.ended_at IS NULL
BEGIN
    UPDATE time_sessions 
    SET duration_seconds = (NEW.ended_at - NEW.started_at - COALESCE(NEW.total_pause_seconds, 0))
    WHERE id = NEW.id;
    
    -- Update total time on task
    UPDATE tasks
    SET time_spent_seconds = time_spent_seconds + (NEW.ended_at - NEW.started_at - COALESCE(NEW.total_pause_seconds, 0))
    WHERE id = NEW.task_id;
END;

-- Shared lists (for collaboration lite - future feature)
CREATE TABLE shared_lists (
    id TEXT PRIMARY KEY DEFAULT (lower(hex(randomblob(16)))),
    name TEXT NOT NULL,
    description TEXT,
    created_at INTEGER NOT NULL DEFAULT (strftime('%s', 'now')),
    owner_id TEXT NOT NULL,
    
    -- Sync with server
    server_id TEXT, -- ID on the sync server
    last_synced_at INTEGER
);

CREATE TABLE shared_list_members (
    list_id TEXT NOT NULL,
    user_id TEXT NOT NULL,
    role TEXT NOT NULL CHECK(role IN ('owner', 'member')),
    added_at INTEGER NOT NULL DEFAULT (strftime('%s', 'now')),
    
    PRIMARY KEY (list_id, user_id),
    FOREIGN KEY(list_id) REFERENCES shared_lists(id) ON DELETE CASCADE
);

CREATE TABLE shared_list_tasks (
    list_id TEXT NOT NULL,
    task_id TEXT NOT NULL,
    assigned_to TEXT,
    
    PRIMARY KEY (list_id, task_id),
    FOREIGN KEY(list_id) REFERENCES shared_lists(id) ON DELETE CASCADE,
    FOREIGN KEY(task_id) REFERENCES tasks(id) ON DELETE CASCADE
);
```

### 3.2 Data Access Patterns

#### High-Frequency Queries (Optimized)

```sql
-- Get current NOW task (dashboard)
SELECT * FROM tasks 
WHERE status = 'now' AND deleted_at IS NULL
LIMIT 1;

-- Get NEXT tasks for current context (dashboard)
SELECT * FROM tasks 
WHERE status = 'next' 
  AND context = ?
  AND deleted_at IS NULL
ORDER BY priority DESC, created_at ASC
LIMIT 10;

-- Get WAITING tasks (dashboard)
SELECT * FROM tasks 
WHERE status = 'waiting'
  AND deleted_at IS NULL
ORDER BY created_at ASC;

-- Quick capture insert
INSERT INTO tasks (title, context, source, device_id, original_input)
VALUES (?, ?, 'desktop_hotkey', ?, ?);

-- Mark task complete
UPDATE tasks 
SET status = 'done', 
    completed_at = strftime('%s', 'now')
WHERE id = ?;
```

#### Medium-Frequency Queries

```sql
-- Get tasks for weekly review
SELECT * FROM tasks
WHERE status IN ('next', 'waiting', 'scheduled')
  AND deleted_at IS NULL
  AND (scheduled_for IS NULL OR scheduled_for <= strftime('%s', 'now'))
ORDER BY created_at ASC;

-- Get tasks by scheduled date
SELECT * FROM tasks
WHERE scheduled_for BETWEEN ? AND ?
  AND deleted_at IS NULL
ORDER BY scheduled_for ASC;

-- Search tasks by title/notes
SELECT * FROM tasks
WHERE (title LIKE ? OR notes LIKE ?)
  AND deleted_at IS NULL
ORDER BY updated_at DESC
LIMIT 50;
```

#### Low-Frequency Queries (Analytics)

```sql
-- Weekly completion stats
SELECT 
    DATE(completed_at, 'unixepoch', 'localtime') as day,
    COUNT(*) as completed_count,
    AVG(time_spent_seconds) as avg_time
FROM tasks
WHERE completed_at BETWEEN ? AND ?
  AND status = 'done'
GROUP BY day
ORDER BY day;

-- Task aging report
SELECT 
    id,
    title,
    context,
    created_at,
    (strftime('%s', 'now') - created_at) / 86400 as age_days
FROM tasks
WHERE status IN ('next', 'waiting')
  AND deleted_at IS NULL
  AND (strftime('%s', 'now') - created_at) > 1209600 -- 14 days
ORDER BY age_days DESC;

-- Context distribution
SELECT 
    context,
    COUNT(*) as task_count,
    AVG(time_spent_seconds) as avg_time
FROM tasks
WHERE status = 'done'
  AND completed_at > ?
GROUP BY context;
```

### 3.3 Data Migration Strategy

```rust
// migrations/mod.rs
pub struct Migration {
    pub version: i32,
    pub up: &'static str,
    pub down: &'static str,
}

pub const MIGRATIONS: &[Migration] = &[
    Migration {
        version: 1,
        up: include_str!("001_initial_schema.sql"),
        down: "DROP TABLE IF EXISTS tasks; DROP TABLE IF EXISTS reviews; -- etc",
    },
    // Future migrations...
];

pub async fn run_migrations(db: &Database) -> Result<()> {
    let current_version = get_current_version(db).await?;
    
    for migration in MIGRATIONS.iter() {
        if migration.version > current_version {
            execute_migration(db, migration).await?;
        }
    }
    
    Ok(())
}
```

### 3.4 Data Synchronization Model

#### Sync Record Structure

```json
{
  "sync_id": "abc123",
  "timestamp": 1707177600,
  "device_id": "desktop-odin",
  "operations": [
    {
      "type": "insert",
      "table": "tasks",
      "record": {
        "id": "task-123",
        "title": "Fix 3CX integration",
        "status": "now",
        "created_at": 1707177000,
        "sync_version": 1
      }
    },
    {
      "type": "update",
      "table": "tasks",
      "record_id": "task-456",
      "changes": {
        "status": "done",
        "completed_at": 1707177500
      },
      "sync_version": 3
    }
  ]
}
```

#### Conflict Resolution Strategy

```
Last-Write-Wins with Vector Clocks:

1. Each update increments sync_version
2. On conflict, compare sync_version:
   - Higher version wins
   - If equal, compare timestamp
   - If equal, compare device_id (lexicographically)

3. Conflicting record saved to conflict_resolution JSON:
   {
     "conflicted_at": 1707177600,
     "local_version": {...},
     "remote_version": {...},
     "resolution": "remote_won",
     "resolved_by": "automatic"
   }

4. User can review conflicts in UI
```

---

## 4. Component Design

### 4.1 Desktop Application Components

#### 4.1.1 Rust Backend (Tauri)

**File Structure:**
```
src-tauri/
├── src/
│   ├── main.rs              # Entry point
│   ├── commands/            # Tauri command handlers
│   │   ├── mod.rs
│   │   ├── tasks.rs         # Task CRUD operations
│   │   ├── sync.rs          # Sync operations
│   │   ├── settings.rs      # Settings management
│   │   └── analytics.rs     # Analytics (opt-in)
│   ├── db/                  # Database layer
│   │   ├── mod.rs
│   │   ├── connection.rs    # SQLite connection pool
│   │   ├── migrations.rs    # Schema migrations
│   │   ├── models.rs        # Data models
│   │   └── queries.rs       # Query builders
│   ├── sync/                # Sync engine
│   │   ├── mod.rs
│   │   ├── git.rs           # Git operations
│   │   ├── conflict.rs      # Conflict resolution
│   │   └── scheduler.rs     # Background sync scheduler
│   ├── nlp/                 # Natural language parsing
│   │   ├── mod.rs
│   │   ├── parser.rs        # Date/time extraction
│   │   └── patterns.rs      # Regex patterns
│   ├── context/             # Context detection
│   │   ├── mod.rs
│   │   ├── time.rs          # Time-based detection
│   │   ├── activity.rs      # Active window detection
│   │   └── location.rs      # Network-based detection
│   ├── system/              # System integration
│   │   ├── mod.rs
│   │   ├── hotkey.rs        # Global hotkey registration
│   │   ├── tray.rs          # System tray icon
│   │   └── notifications.rs # Native notifications
│   └── utils/               # Utilities
│       ├── mod.rs
│       ├── time.rs          # Time utilities
│       └── crypto.rs        # Optional encryption
├── Cargo.toml
└── tauri.conf.json          # Tauri configuration
```

**Key Modules:**

**commands/tasks.rs:**
```rust
use tauri::State;
use crate::db::{Database, Task, TaskStatus};
use crate::nlp::Parser;

#[tauri::command]
pub async fn quick_capture(
    title: String,
    db: State<'_, Database>,
    parser: State<'_, Parser>,
) -> Result<Task, String> {
    // Parse natural language input
    let parsed = parser.parse(&title)?;
    
    // Create task with parsed data
    let task = Task {
        title: parsed.title,
        status: TaskStatus::Next,
        scheduled_for: parsed.scheduled_time,
        tags: parsed.tags,
        original_input: Some(title),
        source: "desktop_hotkey".to_string(),
        ..Default::default()
    };
    
    // Insert into database
    let created = db.insert_task(task).await?;
    
    // Trigger sync in background
    tokio::spawn(async move {
        let _ = trigger_sync(db).await;
    });
    
    Ok(created)
}

#[tauri::command]
pub async fn get_dashboard_data(
    context: Option<String>,
    db: State<'_, Database>,
) -> Result<DashboardData, String> {
    let now_task = db.get_now_task().await?;
    let next_tasks = db.get_next_tasks(context, 10).await?;
    let waiting_tasks = db.get_waiting_tasks().await?;
    let next_review = db.get_next_review_date().await?;
    
    Ok(DashboardData {
        now_task,
        next_tasks,
        waiting_tasks,
        next_review,
    })
}

#[tauri::command]
pub async fn complete_task(
    task_id: String,
    db: State<'_, Database>,
) -> Result<(), String> {
    // Complete the task
    db.complete_task(&task_id).await?;
    
    // Start time tracking for next NOW task if it auto-promoted
    if let Some(new_now) = db.get_now_task().await? {
        db.start_time_session(&new_now.id).await?;
    }
    
    Ok(())
}
```

**sync/git.rs:**
```rust
use git2::{Repository, Signature, IndexAddOption};
use std::path::PathBuf;
use tokio::task;

pub struct GitSync {
    repo_path: PathBuf,
    remote_url: String,
}

impl GitSync {
    pub async fn sync(&self) -> Result<SyncResult, SyncError> {
        // Run blocking Git operations in thread pool
        let repo_path = self.repo_path.clone();
        let remote_url = self.remote_url.clone();
        
        task::spawn_blocking(move || {
            let repo = Repository::open(&repo_path)?;
            
            // Stage changes
            let mut index = repo.index()?;
            index.add_all(["taskflow.db"].iter(), IndexAddOption::DEFAULT, None)?;
            index.write()?;
            
            // Commit
            let tree_id = index.write_tree()?;
            let tree = repo.find_tree(tree_id)?;
            let sig = Signature::now("TaskFlow", "taskflow@local")?;
            let parent = repo.head()?.peel_to_commit()?;
            
            repo.commit(
                Some("HEAD"),
                &sig,
                &sig,
                &format!("Sync: {}", chrono::Utc::now()),
                &tree,
                &[&parent],
            )?;
            
            // Pull with rebase
            let mut remote = repo.find_remote("origin")?;
            remote.fetch(&["main"], None, None)?;
            
            // Rebase
            let fetch_head = repo.find_reference("FETCH_HEAD")?;
            let fetch_commit = repo.reference_to_annotated_commit(&fetch_head)?;
            let analysis = repo.merge_analysis(&[&fetch_commit])?;
            
            if analysis.0.is_up_to_date() {
                return Ok(SyncResult::UpToDate);
            }
            
            if analysis.0.is_fast_forward() {
                // Fast-forward merge
                let refname = "refs/heads/main";
                let mut reference = repo.find_reference(refname)?;
                reference.set_target(fetch_commit.id(), "Fast-forward")?;
                repo.set_head(refname)?;
                repo.checkout_head(Some(git2::build::CheckoutBuilder::default().force()))?;
                
                Ok(SyncResult::FastForward)
            } else {
                // Conflict - need manual resolution
                Ok(SyncResult::Conflict)
            }
        }).await?
    }
}
```

**nlp/parser.rs:**
```rust
use chrono::{DateTime, Local, Duration};
use regex::Regex;

pub struct Parser {
    time_patterns: Vec<TimePattern>,
    tag_pattern: Regex,
}

impl Parser {
    pub fn new() -> Self {
        Self {
            time_patterns: vec![
                TimePattern::new(r"tomorrow at (\d{1,2}):?(\d{2})?\s*(am|pm)?", |caps| {
                    // Parse time and return DateTime
                }),
                TimePattern::new(r"next (monday|tuesday|wednesday|...)", |caps| {
                    // Calculate next occurrence of weekday
                }),
                TimePattern::new(r"in (\d+) (hour|day|week)s?", |caps| {
                    // Add duration to current time
                }),
            ],
            tag_pattern: Regex::new(r"#(\w+)").unwrap(),
        }
    }
    
    pub fn parse(&self, input: &str) -> Result<ParsedTask, ParseError> {
        let mut title = input.to_string();
        let mut scheduled_for = None;
        let mut tags = Vec::new();
        
        // Extract time information
        for pattern in &self.time_patterns {
            if let Some((datetime, matched)) = pattern.extract(&title) {
                scheduled_for = Some(datetime);
                title = title.replace(&matched, "").trim().to_string();
                break;
            }
        }
        
        // Extract tags
        for cap in self.tag_pattern.captures_iter(&title) {
            tags.push(cap[1].to_string());
        }
        title = self.tag_pattern.replace_all(&title, "").trim().to_string();
        
        Ok(ParsedTask {
            title,
            scheduled_for,
            tags,
        })
    }
}
```

#### 4.1.2 React Frontend

**File Structure:**
```
src/
├── App.tsx                  # Main app component
├── main.tsx                 # Entry point
├── index.css                # Global styles
├── components/
│   ├── Dashboard/
│   │   ├── Dashboard.tsx
│   │   ├── NowTask.tsx
│   │   ├── NextTasks.tsx
│   │   └── WaitingTasks.tsx
│   ├── QuickCapture/
│   │   ├── QuickCapture.tsx
│   │   └── CaptureOverlay.tsx
│   ├── Review/
│   │   ├── ReviewFlow.tsx
│   │   ├── ReviewTriage.tsx
│   │   └── ReviewSummary.tsx
│   ├── Settings/
│   │   └── Settings.tsx
│   └── common/
│       ├── TaskCard.tsx
│       ├── TimeDisplay.tsx
│       └── ContextBadge.tsx
├── hooks/
│   ├── useTasks.ts
│   ├── useSync.ts
│   ├── useReview.ts
│   └── useHotkeys.ts
├── store/
│   ├── taskStore.ts         # Zustand store
│   ├── settingsStore.ts
│   └── syncStore.ts
├── api/
│   └── tauri.ts             # Tauri command wrappers
├── types/
│   └── index.ts             # TypeScript types
└── utils/
    ├── time.ts
    └── formatting.ts
```

**Key Components:**

**store/taskStore.ts:**
```typescript
import create from 'zustand';
import { invoke } from '@tauri-apps/api/tauri';
import { Task, TaskStatus, DashboardData } from '../types';

interface TaskStore {
  // State
  dashboardData: DashboardData | null;
  loading: boolean;
  error: string | null;
  currentContext: string;
  
  // Actions
  loadDashboard: () => Promise<void>;
  quickCapture: (title: string) => Promise<Task>;
  completeTask: (taskId: string) => Promise<void>;
  deferTask: (taskId: string) => Promise<void>;
  deleteTask: (taskId: string) => Promise<void>;
  setContext: (context: string) => void;
  
  // Subscriptions
  subscribeToUpdates: () => void;
}

export const useTaskStore = create<TaskStore>((set, get) => ({
  dashboardData: null,
  loading: false,
  error: null,
  currentContext: 'work',
  
  loadDashboard: async () => {
    set({ loading: true, error: null });
    try {
      const data = await invoke<DashboardData>('get_dashboard_data', {
        context: get().currentContext,
      });
      set({ dashboardData: data, loading: false });
    } catch (error) {
      set({ error: error as string, loading: false });
    }
  },
  
  quickCapture: async (title: string) => {
    const task = await invoke<Task>('quick_capture', { title });
    await get().loadDashboard(); // Refresh dashboard
    return task;
  },
  
  completeTask: async (taskId: string) => {
    await invoke('complete_task', { taskId });
    await get().loadDashboard();
  },
  
  deferTask: async (taskId: string) => {
    await invoke('defer_task', { taskId });
    await get().loadDashboard();
  },
  
  deleteTask: async (taskId: string) => {
    await invoke('delete_task', { taskId });
    await get().loadDashboard();
  },
  
  setContext: (context: string) => {
    set({ currentContext: context });
    get().loadDashboard();
  },
  
  subscribeToUpdates: () => {
    // Listen for background sync updates
    listen('task-updated', () => {
      get().loadDashboard();
    });
  },
}));
```

**components/Dashboard/Dashboard.tsx:**
```typescript
import React, { useEffect } from 'react';
import { useTaskStore } from '../../store/taskStore';
import NowTask from './NowTask';
import NextTasks from './NextTasks';
import WaitingTasks from './WaitingTasks';

export const Dashboard: React.FC = () => {
  const { dashboardData, loading, loadDashboard, subscribeToUpdates } = useTaskStore();
  
  useEffect(() => {
    loadDashboard();
    subscribeToUpdates();
    
    // Refresh every 60 seconds
    const interval = setInterval(loadDashboard, 60000);
    return () => clearInterval(interval);
  }, []);
  
  if (loading && !dashboardData) {
    return <div className="loading">Loading...</div>;
  }
  
  return (
    <div className="dashboard">
      <header className="dashboard-header">
        <h1>TaskFlow</h1>
        <ContextSelector />
      </header>
      
      <main className="dashboard-main">
        <section className="now-section">
          <h2>NOW</h2>
          {dashboardData?.nowTask ? (
            <NowTask task={dashboardData.nowTask} />
          ) : (
            <EmptyState message="No active task. Start one from NEXT." />
          )}
        </section>
        
        <section className="next-section">
          <h2>NEXT ({dashboardData?.nextTasks.length || 0})</h2>
          <NextTasks tasks={dashboardData?.nextTasks || []} />
        </section>
        
        <section className="waiting-section">
          <h2>WAITING ({dashboardData?.waitingTasks.length || 0})</h2>
          <WaitingTasks tasks={dashboardData?.waitingTasks || []} />
        </section>
      </main>
      
      <footer className="dashboard-footer">
        {dashboardData?.nextReview && (
          <div className="review-reminder">
            ⚠️ Review due in {formatRelativeTime(dashboardData.nextReview)}
          </div>
        )}
      </footer>
    </div>
  );
};
```

**components/QuickCapture/CaptureOverlay.tsx:**
```typescript
import React, { useState, useEffect, useRef } from 'react';
import { useTaskStore } from '../../store/taskStore';
import { listen } from '@tauri-apps/api/event';

export const CaptureOverlay: React.FC = () => {
  const [visible, setVisible] = useState(false);
  const [input, setInput] = useState('');
  const inputRef = useRef<HTMLInputElement>(null);
  const { quickCapture } = useTaskStore();
  
  useEffect(() => {
    // Listen for hotkey trigger from Rust backend
    const unlisten = listen('show-quick-capture', () => {
      setVisible(true);
      setTimeout(() => inputRef.current?.focus(), 50);
    });
    
    return () => {
      unlisten.then(fn => fn());
    };
  }, []);
  
  const handleSubmit = async (e: React.FormEvent) => {
    e.preventDefault();
    if (!input.trim()) return;
    
    try {
      await quickCapture(input);
      setInput('');
      setVisible(false);
    } catch (error) {
      console.error('Failed to capture task:', error);
    }
  };
  
  const handleKeyDown = (e: React.KeyboardEvent) => {
    if (e.key === 'Escape') {
      setInput('');
      setVisible(false);
    }
  };
  
  if (!visible) return null;
  
  return (
    <div className="capture-overlay" onClick={() => setVisible(false)}>
      <div className="capture-card" onClick={e => e.stopPropagation()}>
        <form onSubmit={handleSubmit}>
          <input
            ref={inputRef}
            type="text"
            value={input}
            onChange={e => setInput(e.target.value)}
            onKeyDown={handleKeyDown}
            placeholder="What needs to be done? (e.g., 'Email John tomorrow at 2pm')"
            className="capture-input"
            autoComplete="off"
          />
          <div className="capture-hint">
            Press Enter to save, Esc to cancel
          </div>
        </form>
      </div>
    </div>
  );
};
```

### 4.2 Mobile Application Components

**File Structure:**
```
lib/
├── main.dart                # App entry point
├── app.dart                 # Material app config
├── models/
│   ├── task.dart
│   ├── review.dart
│   └── settings.dart
├── providers/
│   ├── task_provider.dart
│   ├── sync_provider.dart
│   └── settings_provider.dart
├── repositories/
│   ├── task_repository.dart
│   ├── database.dart
│   └── sync_repository.dart
├── screens/
│   ├── dashboard/
│   │   ├── dashboard_screen.dart
│   │   ├── widgets/
│   │   │   ├── now_task_card.dart
│   │   │   ├── next_task_list.dart
│   │   │   └── waiting_task_list.dart
│   ├── review/
│   │   ├── review_screen.dart
│   │   └── triage_card.dart
│   ├── settings/
│   │   └── settings_screen.dart
│   └── quick_add/
│       └── quick_add_sheet.dart
├── widgets/
│   ├── task_card.dart
│   ├── context_chip.dart
│   └── time_display.dart
├── services/
│   ├── notification_service.dart
│   ├── background_sync.dart
│   └── context_detector.dart
└── utils/
    ├── time_utils.dart
    └── constants.dart

android/
├── app/
│   └── src/main/kotlin/
│       └── com/taskflow/
│           ├── MainActivity.kt
│           └── widgets/
│               ├── QuickAddWidget.kt
│               └── DashboardWidget.kt

ios/
└── Runner/
    ├── AppDelegate.swift
    └── Widgets/
        ├── QuickAddWidget.swift
        └── DashboardWidget.swift
```

**Key Components:**

**providers/task_provider.dart:**
```dart
import 'package:flutter_riverpod/flutter_riverpod.dart';
import '../models/task.dart';
import '../repositories/task_repository.dart';

final taskRepositoryProvider = Provider((ref) => TaskRepository());

final dashboardDataProvider = FutureProvider.family<DashboardData, String?>((ref, context) async {
  final repository = ref.watch(taskRepositoryProvider);
  return await repository.getDashboardData(context);
});

final nowTaskProvider = StreamProvider<Task?>((ref) {
  final repository = ref.watch(taskRepositoryProvider);
  return repository.watchNowTask();
});

class TaskNotifier extends StateNotifier<AsyncValue<List<Task>>> {
  final TaskRepository _repository;
  
  TaskNotifier(this._repository) : super(const AsyncValue.loading()) {
    _loadTasks();
  }
  
  Future<void> _loadTasks() async {
    state = const AsyncValue.loading();
    try {
      final tasks = await _repository.getAllTasks();
      state = AsyncValue.data(tasks);
    } catch (error, stackTrace) {
      state = AsyncValue.error(error, stackTrace);
    }
  }
  
  Future<void> quickCapture(String title) async {
    try {
      await _repository.createTask(title);
      await _loadTasks();
    } catch (error) {
      // Handle error
      rethrow;
    }
  }
  
  Future<void> completeTask(String taskId) async {
    await _repository.completeTask(taskId);
    await _loadTasks();
  }
}

final taskNotifierProvider = StateNotifierProvider<TaskNotifier, AsyncValue<List<Task>>>((ref) {
  return TaskNotifier(ref.watch(taskRepositoryProvider));
});
```

**repositories/database.dart:**
```dart
import 'package:sqflite/sqflite.dart';
import 'package:path/path.dart';

class AppDatabase {
  static final AppDatabase _instance = AppDatabase._internal();
  static Database? _database;
  
  factory AppDatabase() => _instance;
  
  AppDatabase._internal();
  
  Future<Database> get database async {
    if (_database != null) return _database!;
    _database = await _initDatabase();
    return _database!;
  }
  
  Future<Database> _initDatabase() async {
    final dbPath = await getDatabasesPath();
    final path = join(dbPath, 'taskflow.db');
    
    return await openDatabase(
      path,
      version: 1,
      onCreate: _onCreate,
      onUpgrade: _onUpgrade,
    );
  }
  
  Future<void> _onCreate(Database db, int version) async {
    // Execute same schema as desktop version
    await db.execute('''
      CREATE TABLE tasks (
        id TEXT PRIMARY KEY,
        title TEXT NOT NULL,
        status TEXT NOT NULL,
        -- ... rest of schema
      )
    ''');
    
    // Create indexes
    await db.execute('CREATE INDEX idx_tasks_status ON tasks(status)');
  }
  
  Future<void> _onUpgrade(Database db, int oldVersion, int newVersion) async {
    // Run migrations
  }
}
```

**android/app/src/main/kotlin/widgets/QuickAddWidget.kt:**
```kotlin
package com.taskflow.widgets

import android.app.PendingIntent
import android.appwidget.AppWidgetManager
import android.appwidget.AppWidgetProvider
import android.content.Context
import android.content.Intent
import android.widget.RemoteViews
import com.taskflow.R
import com.taskflow.MainActivity

class QuickAddWidget : AppWidgetProvider() {
    override fun onUpdate(
        context: Context,
        appWidgetManager: AppWidgetManager,
        appWidgetIds: IntArray
    ) {
        for (appWidgetId in appWidgetIds) {
            updateWidget(context, appWidgetManager, appWidgetId)
        }
    }
    
    private fun updateWidget(
        context: Context,
        appWidgetManager: AppWidgetManager,
        appWidgetId: Int
    ) {
        val views = RemoteViews(context.packageName, R.layout.widget_quick_add)
        
        // Set up click to open quick add
        val intent = Intent(context, MainActivity::class.java).apply {
            action = "QUICK_ADD"
            flags = Intent.FLAG_ACTIVITY_NEW_TASK or Intent.FLAG_ACTIVITY_CLEAR_TASK
        }
        val pendingIntent = PendingIntent.getActivity(
            context, 0, intent,
            PendingIntent.FLAG_UPDATE_CURRENT or PendingIntent.FLAG_IMMUTABLE
        )
        
        views.setOnClickPendingIntent(R.id.quick_add_button, pendingIntent)
        
        appWidgetManager.updateAppWidget(appWidgetId, views)
    }
}
```

### 4.3 MCP Server Components

**File Structure:**
```
taskflow-mcp/
├── pyproject.toml
├── README.md
├── src/
│   └── taskflow_mcp/
│       ├── __init__.py
│       ├── server.py          # Main MCP server
│       ├── database.py        # Database access
│       ├── tools.py           # Tool implementations
│       └── utils.py           # Utilities
└── tests/
    ├── test_server.py
    └── test_tools.py
```

**server.py:**
```python
import asyncio
from mcp.server import Server
from mcp.server.stdio import stdio_server
from mcp import types
from .database import TaskDatabase
from .tools import (
    task_add,
    task_complete,
    task_list,
    task_current,
    task_defer,
    task_delete,
)

app = Server("taskflow")
db = TaskDatabase()

@app.list_tools()
async def list_tools() -> list[types.Tool]:
    return [
        types.Tool(
            name="task_add",
            description="Add a new task to TaskFlow",
            inputSchema={
                "type": "object",
                "properties": {
                    "title": {
                        "type": "string",
                        "description": "Task title"
                    },
                    "context": {
                        "type": "string",
                        "description": "Task context (work, personal, infrastructure, development)",
                        "enum": ["work", "personal", "infrastructure", "development", "communication"],
                        "default": "development"
                    }
                },
                "required": ["title"]
            }
        ),
        types.Tool(
            name="task_complete",
            description="Mark a task as complete",
            inputSchema={
                "type": "object",
                "properties": {
                    "task_id": {
                        "type": "string",
                        "description": "Task ID to complete"
                    }
                },
                "required": ["task_id"]
            }
        ),
        types.Tool(
            name="task_list",
            description="List tasks, optionally filtered by context and status",
            inputSchema={
                "type": "object",
                "properties": {
                    "context": {
                        "type": "string",
                        "description": "Filter by context",
                        "enum": ["work", "personal", "infrastructure", "development", "communication"]
                    },
                    "status": {
                        "type": "string",
                        "description": "Filter by status",
                        "enum": ["now", "next", "waiting", "scheduled"],
                        "default": "next"
                    },
                    "limit": {
                        "type": "integer",
                        "description": "Maximum number of tasks to return",
                        "default": 10
                    }
                }
            }
        ),
        types.Tool(
            name="task_current",
            description="Get the current NOW task",
            inputSchema={
                "type": "object",
                "properties": {}
            }
        ),
    ]

@app.call_tool()
async def call_tool(name: str, arguments: dict) -> list[types.TextContent]:
    if name == "task_add":
        result = await task_add(db, **arguments)
    elif name == "task_complete":
        result = await task_complete(db, **arguments)
    elif name == "task_list":
        result = await task_list(db, **arguments)
    elif name == "task_current":
        result = await task_current(db)
    else:
        raise ValueError(f"Unknown tool: {name}")
    
    return [types.TextContent(type="text", text=result)]

async def main():
    async with stdio_server() as (read_stream, write_stream):
        await app.run(read_stream, write_stream, app.create_initialization_options())

if __name__ == "__main__":
    asyncio.run(main())
```

**tools.py:**
```python
import json
from datetime import datetime
from .database import TaskDatabase

async def task_add(db: TaskDatabase, title: str, context: str = "development") -> str:
    """Add a new task to TaskFlow"""
    task_id = await db.create_task(
        title=title,
        context=context,
        source="mcp"
    )
    return json.dumps({
        "success": True,
        "task_id": task_id,
        "message": f"Task created: {title}"
    })

async def task_complete(db: TaskDatabase, task_id: str) -> str:
    """Mark a task as complete"""
    task = await db.get_task(task_id)
    if not task:
        return json.dumps({
            "success": False,
            "error": f"Task not found: {task_id}"
        })
    
    await db.complete_task(task_id)
    return json.dumps({
        "success": True,
        "message": f"Task completed: {task['title']}"
    })

async def task_list(
    db: TaskDatabase,
    context: str | None = None,
    status: str = "next",
    limit: int = 10
) -> str:
    """List tasks with optional filters"""
    tasks = await db.get_tasks(
        context=context,
        status=status,
        limit=limit
    )
    
    return json.dumps({
        "success": True,
        "count": len(tasks),
        "tasks": [
            {
                "id": t["id"],
                "title": t["title"],
                "context": t["context"],
                "created_at": datetime.fromtimestamp(t["created_at"]).isoformat()
            }
            for t in tasks
        ]
    })

async def task_current(db: TaskDatabase) -> str:
    """Get the current NOW task"""
    task = await db.get_now_task()
    
    if not task:
        return json.dumps({
            "success": True,
            "task": None,
            "message": "No task is currently active"
        })
    
    return json.dumps({
        "success": True,
        "task": {
            "id": task["id"],
            "title": task["title"],
            "context": task["context"],
            "time_spent_seconds": task["time_spent_seconds"],
            "started_at": datetime.fromtimestamp(task["started_at"]).isoformat() if task["started_at"] else None
        }
    })
```

---

## 5. API Specifications

### 5.1 Tauri Commands API

**Task Operations:**
```typescript
// Quick capture with NLP parsing
invoke<Task>('quick_capture', { title: string }): Promise<Task>

// Get dashboard data
invoke<DashboardData>('get_dashboard_data', { context?: string }): Promise<DashboardData>

// Task state changes
invoke<void>('complete_task', { taskId: string }): Promise<void>
invoke<void>('defer_task', { taskId: string }): Promise<void>
invoke<void>('delete_task', { taskId: string }): Promise<void>
invoke<void>('set_task_status', { taskId: string, status: TaskStatus }): Promise<void>

// Task updates
invoke<Task>('update_task', { taskId: string, updates: Partial<Task> }): Promise<Task>
invoke<void>('add_note', { taskId: string, note: string }): Promise<void>
invoke<void>('schedule_task', { taskId: string, scheduledFor: number }): Promise<void>
```

**Sync Operations:**
```typescript
// Manual sync trigger
invoke<SyncResult>('sync_now'): Promise<SyncResult>

// Sync status
invoke<SyncStatus>('get_sync_status'): Promise<SyncStatus>

// Conflict resolution
invoke<void>('resolve_conflict', { 
  conflictId: string, 
  resolution: 'local' | 'remote' | 'manual',
  manualData?: Task 
}): Promise<void>
```

**Review Operations:**
```typescript
// Start weekly review
invoke<Review>('start_review'): Promise<Review>

// Triage task during review
invoke<void>('review_triage', { 
  reviewId: string,
  taskId: string, 
  action: 'complete' | 'defer' | 'schedule' | 'delete' | 'someday'
}): Promise<void>

// Complete review
invoke<ReviewSummary>('complete_review', { reviewId: string }): Promise<ReviewSummary>
```

**Settings Operations:**
```typescript
invoke<Settings>('get_settings'): Promise<Settings>
invoke<void>('update_settings', { settings: Partial<Settings> }): Promise<void>
invoke<void>('set_hotkey', { action: string, hotkey: string }): Promise<void>
```

**Analytics Operations (Opt-in):**
```typescript
invoke<TaskStats>('get_task_stats', { 
  startDate: number, 
  endDate: number 
}): Promise<TaskStats>

invoke<AgingReport>('get_aging_report'): Promise<AgingReport>
invoke<ContextDistribution>('get_context_distribution'): Promise<ContextDistribution>
```

### 5.2 Event System

**Tauri Events (Rust → Frontend):**
```typescript
// Task updates
listen<Task>('task-created', (event) => { })
listen<Task>('task-updated', (event) => { })
listen<string>('task-deleted', (event) => { })
listen<Task>('task-completed', (event) => { })

// Sync events
listen<SyncProgress>('sync-progress', (event) => { })
listen<SyncResult>('sync-complete', (event) => { })
listen<SyncError>('sync-error', (event) => { })

// Review events
listen<void>('review-due', (event) => { })
listen<void>('review-overdue', (event) => { })

// Context events
listen<string>('context-changed', (event) => { })

// UI events
listen<void>('show-quick-capture', (event) => { })
listen<void>('show-dashboard', (event) => { })
```

### 5.3 Mobile Platform Channels

**Android (MethodChannel):**
```kotlin
class TaskFlowPlugin : MethodCallHandler {
    override fun onMethodCall(call: MethodCall, result: Result) {
        when (call.method) {
            "quickAdd" -> {
                val title = call.argument<String>("title")
                // Open quick add dialog
                result.success(true)
            }
            "updateWidget" -> {
                // Update home screen widget
                updateHomeWidget()
                result.success(true)
            }
            "startBackgroundSync" -> {
                // Schedule background sync with WorkManager
                scheduleSync()
                result.success(true)
            }
        }
    }
}
```

**iOS (FlutterMethodChannel):**
```swift
class TaskFlowPlugin: NSObject, FlutterPlugin {
    static func register(with registrar: FlutterPluginRegistrar) {
        let channel = FlutterMethodChannel(
            name: "com.taskflow/platform",
            binaryMessenger: registrar.messenger()
        )
        let instance = TaskFlowPlugin()
        registrar.addMethodCallDelegate(instance, channel: channel)
    }
    
    func handle(_ call: FlutterMethodCall, result: @escaping FlutterResult) {
        switch call.method {
        case "quickAdd":
            if let args = call.arguments as? [String: Any],
               let title = args["title"] as? String {
                // Show quick add
                result(true)
            }
        case "updateWidget":
            // Update widget via WidgetKit
            WidgetCenter.shared.reloadAllTimelines()
            result(true)
        default:
            result(FlutterMethodNotImplemented)
        }
    }
}
```

### 5.4 MCP Protocol

**Standard MCP Interface:**
```json
{
  "jsonrpc": "2.0",
  "method": "tools/call",
  "params": {
    "name": "task_add",
    "arguments": {
      "title": "Fix Ghost blog SSL issue",
      "context": "infrastructure"
    }
  },
  "id": 1
}
```

**Response:**
```json
{
  "jsonrpc": "2.0",
  "result": {
    "content": [
      {
        "type": "text",
        "text": "{\"success\": true, \"task_id\": \"abc123\", \"message\": \"Task created: Fix Ghost blog SSL issue\"}"
      }
    ]
  },
  "id": 1
}
```

---

## 6. Security & Privacy

### 6.1 Data Encryption

**At Rest (Optional):**
```rust
use sqlcipher::Connection;

pub struct EncryptedDatabase {
    key: String,
}

impl EncryptedDatabase {
    pub fn open(path: &str, key: &str) -> Result<Connection> {
        let conn = Connection::open(path)?;
        conn.execute(&format!("PRAGMA key = '{}'", key), [])?;
        Ok(conn)
    }
}
```

**User Settings:**
```typescript
interface SecuritySettings {
  enableEncryption: boolean;
  encryptionKey?: string; // Stored in OS keychain
  requirePinOnOpen: boolean;
  autoLockAfterMinutes: number;
}
```

### 6.2 Sync Security

**SSH Key Authentication:**
```rust
use git2::Cred;

pub fn credentials_callback(
    _user: &str,
    _user_from_url: Option<&str>,
    _cred: git2::CredentialType,
) -> Result<Cred, git2::Error> {
    let ssh_key_path = home::home_dir()
        .unwrap()
        .join(".ssh/id_rsa");
    
    Cred::ssh_key(
        "git",
        None,
        &ssh_key_path,
        None,
    )
}
```

**HTTPS with Token:**
```rust
pub fn https_credentials(token: &str) -> impl Fn(&str, Option<&str>, git2::CredentialType) -> Result<Cred, git2::Error> {
    let token = token.to_string();
    move |_url, _username, _cred_type| {
        Cred::userpass_plaintext("token", &token)
    }
}
```

### 6.3 Privacy Considerations

**Minimal Data Collection:**
- No telemetry by default
- Opt-in analytics only
- No PII in analytics events
- All data stays local unless sync enabled

**Analytics Events (If Opted In):**
```typescript
interface AnalyticsEvent {
  type: 'task_created' | 'task_completed' | 'review_completed';
  timestamp: number;
  context: string; // Hashed
  // NO task titles, notes, or personal data
}
```

**Data Retention:**
```sql
-- Auto-delete old analytics events
CREATE TRIGGER cleanup_old_analytics
AFTER INSERT ON analytics_events
BEGIN
  DELETE FROM analytics_events
  WHERE timestamp < strftime('%s', 'now', '-90 days');
END;
```

---

## 7. Performance & Scalability

### 7.1 Performance Targets

| Operation | Target | Measurement Method |
|-----------|--------|-------------------|
| Quick capture | < 200ms | Time from hotkey to DB insert |
| Dashboard render | < 100ms | First contentful paint |
| Task completion | < 50ms | DB update + UI refresh |
| Sync operation | < 5s | For 1000 tasks |
| Search query | < 100ms | Full-text search across all tasks |
| Weekly review load | < 500ms | Load all review tasks |
| App cold start | < 2s | Desktop launch to interactive |
| Mobile widget update | < 100ms | Data fetch + render |

### 7.2 Database Optimization

**Connection Pooling:**
```rust
use sqlx::sqlite::SqlitePoolOptions;

pub async fn create_pool(database_url: &str) -> Result<SqlitePool> {
    SqlitePoolOptions::new()
        .max_connections(5)
        .connect(database_url)
        .await
}
```

**Query Caching:**
```rust
use cached::proc_macro::cached;

#[cached(time = 60, result = true)]
async fn get_dashboard_data(context: Option<String>) -> Result<DashboardData> {
    // Expensive query cached for 60 seconds
}
```

**Prepared Statements:**
```rust
pub struct TaskQueries {
    get_now: Statement<'static>,
    get_next: Statement<'static>,
    insert_task: Statement<'static>,
}

impl TaskQueries {
    pub fn new(conn: &Connection) -> Result<Self> {
        Ok(Self {
            get_now: conn.prepare("SELECT * FROM tasks WHERE status = 'now' LIMIT 1")?,
            get_next: conn.prepare("SELECT * FROM tasks WHERE status = 'next' ORDER BY priority DESC LIMIT ?")?,
            insert_task: conn.prepare("INSERT INTO tasks (title, context, status) VALUES (?, ?, ?)")?,
        })
    }
}
```

### 7.3 Sync Performance

**Incremental Sync:**
```rust
pub async fn incremental_sync(since: i64) -> Result<Vec<Task>> {
    // Only sync tasks modified since last sync
    let tasks = query!(
        "SELECT * FROM tasks WHERE updated_at > ? ORDER BY updated_at",
        since
    )
    .fetch_all(&pool)
    .await?;
    
    Ok(tasks)
}
```

**Batch Operations:**
```rust
pub async fn batch_insert(tasks: Vec<Task>) -> Result<()> {
    let mut tx = pool.begin().await?;
    
    for task in tasks {
        query!(
            "INSERT INTO tasks (...) VALUES (...)",
            // ... parameters
        )
        .execute(&mut tx)
        .await?;
    }
    
    tx.commit().await?;
    Ok(())
}
```

### 7.4 Mobile Performance

**Lazy Loading:**
```dart
class TaskListView extends StatelessWidget {
  @override
  Widget build(BuildContext context) {
    return ListView.builder(
      itemCount: tasks.length,
      cacheExtent: 1000, // Pre-render 1000px ahead
      itemBuilder: (context, index) {
        return TaskCard(task: tasks[index]);
      },
    );
  }
}
```

**Image/Icon Caching:**
```dart
final iconCache = <String, Widget>{};

Widget getCachedIcon(String name) {
  return iconCache.putIfAbsent(
    name,
    () => Icon(getIconData(name)),
  );
}
```

**Background Sync Optimization:**
```dart
class BackgroundSync {
  static Future<void> sync() async {
    // Only sync if on WiFi and battery > 20%
    final connectivity = await Connectivity().checkConnectivity();
    final battery = await Battery().batteryLevel;
    
    if (connectivity == ConnectivityResult.wifi && battery > 20) {
      await performSync();
    }
  }
}
```

---

## 8. Deployment & Operations

### 8.1 Build Configuration

**Desktop (Tauri):**
```json
// tauri.conf.json
{
  "build": {
    "beforeBuildCommand": "npm run build",
    "beforeDevCommand": "npm run dev",
    "devPath": "http://localhost:5173",
    "distDir": "../dist"
  },
  "package": {
    "productName": "TaskFlow",
    "version": "0.1.0"
  },
  "tauri": {
    "allowlist": {
      "all": false,
      "shell": {
        "open": true
      },
      "fs": {
        "scope": ["$APPDATA/*", "$HOME/.taskflow/*"]
      },
      "dialog": {
        "open": true,
        "save": true
      }
    },
    "bundle": {
      "active": true,
      "category": "Productivity",
      "identifier": "com.brucembudi.taskflow",
      "icon": [
        "icons/32x32.png",
        "icons/128x128.png",
        "icons/128x128@2x.png",
        "icons/icon.icns",
        "icons/icon.ico"
      ],
      "macOS": {
        "minimumSystemVersion": "10.15"
      },
      "windows": {
        "certificateThumbprint": null,
        "digestAlgorithm": "sha256",
        "timestampUrl": ""
      }
    },
    "security": {
      "csp": "default-src 'self'; style-src 'self' 'unsafe-inline'"
    },
    "updater": {
      "active": true,
      "endpoints": [
        "https://releases.taskflow.dev/{{target}}/{{current_version}}"
      ],
      "dialog": true,
      "pubkey": "PUBLIC_KEY_HERE"
    }
  }
}
```

**Mobile (Flutter):**
```yaml
# pubspec.yaml
flutter:
  version: 3.16.5
  
dependencies:
  flutter:
    sdk: flutter
  sqflite: ^2.3.2
  riverpod: ^2.4.0
  shared_preferences: ^2.2.2
  
build_configuration:
  android:
    minSdkVersion: 24
    targetSdkVersion: 34
    compileSdkVersion: 34
  ios:
    minimumDeploymentTarget: 15.0
```

### 8.2 CI/CD Pipeline

**GitHub Actions:**
```yaml
# .github/workflows/build.yml
name: Build and Release

on:
  push:
    tags:
      - 'v*'

jobs:
  build-desktop:
    strategy:
      matrix:
        os: [ubuntu-latest, macos-latest, windows-latest]
    runs-on: ${{ matrix.os }}
    
    steps:
      - uses: actions/checkout@v3
      
      - name: Setup Node.js
        uses: actions/setup-node@v3
        with:
          node-version: '18'
      
      - name: Setup Rust
        uses: actions-rs/toolchain@v1
        with:
          toolchain: stable
      
      - name: Install dependencies
        run: npm install
      
      - name: Build app
        run: npm run tauri build
      
      - name: Upload artifacts
        uses: actions/upload-artifact@v3
        with:
          name: taskflow-${{ matrix.os }}
          path: src-tauri/target/release/bundle/
  
  build-mobile:
    runs-on: macos-latest
    
    steps:
      - uses: actions/checkout@v3
      
      - name: Setup Flutter
        uses: subosito/flutter-action@v2
        with:
          flutter-version: '3.16.5'
      
      - name: Build iOS
        run: |
          cd mobile
          flutter build ios --release --no-codesign
      
      - name: Build Android
        run: |
          cd mobile
          flutter build apk --release
```

### 8.3 Distribution

**Desktop:**
- **macOS:** DMG via GitHub Releases
- **Windows:** MSI installer via GitHub Releases
- **Linux:** AppImage + .deb via GitHub Releases

**Mobile:**
- **iOS:** TestFlight (beta) → App Store
- **Android:** APK direct download + Google Play

### 8.4 Monitoring & Logging

**Application Logs:**
```rust
use tracing::{info, warn, error};
use tracing_subscriber;

pub fn init_logging() {
    tracing_subscriber::fmt()
        .with_max_level(tracing::Level::INFO)
        .with_target(false)
        .init();
    
    info!("TaskFlow started");
}
```

**Error Tracking (Opt-in):**
```rust
use sentry;

pub fn init_sentry(dsn: &str) {
    let _guard = sentry::init((dsn, sentry::ClientOptions {
        release: sentry::release_name!(),
        ..Default::default()
    }));
}
```

**Performance Monitoring:**
```rust
use std::time::Instant;

pub async fn timed_operation<F, T>(name: &str, f: F) -> T
where
    F: Future<Output = T>,
{
    let start = Instant::now();
    let result = f.await;
    let duration = start.elapsed();
    
    info!("{} completed in {:?}", name, duration);
    
    if duration.as_millis() > 1000 {
        warn!("{} took longer than expected: {:?}", name, duration);
    }
    
    result
}
```

---

## 9. Testing Strategy

### 9.1 Unit Tests

**Rust (Backend):**
```rust
#[cfg(test)]
mod tests {
    use super::*;
    
    #[tokio::test]
    async fn test_create_task() {
        let db = setup_test_db().await;
        
        let task = db.create_task("Test task", "personal").await.unwrap();
        
        assert_eq!(task.title, "Test task");
        assert_eq!(task.status, TaskStatus::Next);
        assert_eq!(task.context, "personal");
    }
    
    #[tokio::test]
    async fn test_one_now_task_rule() {
        let db = setup_test_db().await;
        
        let task1 = db.create_task("Task 1", "work").await.unwrap();
        let task2 = db.create_task("Task 2", "work").await.unwrap();
        
        db.set_task_status(&task1.id, TaskStatus::Now).await.unwrap();
        db.set_task_status(&task2.id, TaskStatus::Now).await.unwrap();
        
        // Verify only one NOW task exists
        let now_tasks = db.get_tasks_by_status(TaskStatus::Now).await.unwrap();
        assert_eq!(now_tasks.len(), 1);
        assert_eq!(now_tasks[0].id, task2.id);
        
        // Verify task1 was moved to NEXT
        let task1_updated = db.get_task(&task1.id).await.unwrap();
        assert_eq!(task1_updated.status, TaskStatus::Next);
    }
    
    #[test]
    fn test_nlp_parser() {
        let parser = Parser::new();
        
        let result = parser.parse("Email John tomorrow at 2pm").unwrap();
        assert_eq!(result.title, "Email John");
        assert!(result.scheduled_for.is_some());
        
        let scheduled = result.scheduled_for.unwrap();
        assert_eq!(scheduled.hour(), 14);
    }
}
```

**TypeScript (Frontend):**
```typescript
import { describe, it, expect, beforeEach } from 'vitest';
import { renderHook, act } from '@testing-library/react';
import { useTaskStore } from '../store/taskStore';

describe('Task Store', () => {
  beforeEach(() => {
    // Reset store
    useTaskStore.setState({ dashboardData: null, loading: false });
  });
  
  it('loads dashboard data', async () => {
    const { result } = renderHook(() => useTaskStore());
    
    await act(async () => {
      await result.current.loadDashboard();
    });
    
    expect(result.current.loading).toBe(false);
    expect(result.current.dashboardData).not.toBeNull();
  });
  
  it('quick capture creates task', async () => {
    const { result } = renderHook(() => useTaskStore());
    
    const task = await act(async () => {
      return await result.current.quickCapture('Test task');
    });
    
    expect(task.title).toBe('Test task');
    expect(task.status).toBe('next');
  });
});
```

### 9.2 Integration Tests

**Database Operations:**
```rust
#[tokio::test]
async fn test_weekly_review_flow() {
    let db = setup_test_db().await;
    
    // Create test tasks
    for i in 0..10 {
        db.create_task(&format!("Task {}", i), "work").await.unwrap();
    }
    
    // Start review
    let review = db.start_review().await.unwrap();
    assert_eq!(review.tasks_reviewed, 0);
    
    // Triage tasks
    let tasks = db.get_review_tasks(&review.id).await.unwrap();
    for task in tasks.iter().take(5) {
        db.review_triage(&review.id, &task.id, "completed").await.unwrap();
    }
    
    // Complete review
    let summary = db.complete_review(&review.id).await.unwrap();
    assert_eq!(summary.tasks_completed, 5);
}
```

**Sync Operations:**
```rust
#[tokio::test]
async fn test_sync_roundtrip() {
    let temp_dir = tempdir().unwrap();
    let repo_path = temp_dir.path().join("repo");
    
    // Initialize Git repo
    Repository::init(&repo_path).unwrap();
    
    // Create two database instances (simulating two devices)
    let db1 = Database::new(&repo_path.join("device1.db")).await.unwrap();
    let db2 = Database::new(&repo_path.join("device2.db")).await.unwrap();
    
    // Create task on device 1
    let task = db1.create_task("Test task", "work").await.unwrap();
    
    // Sync device 1
    let sync1 = GitSync::new(&repo_path);
    sync1.sync().await.unwrap();
    
    // Sync device 2
    let sync2 = GitSync::new(&repo_path);
    sync2.sync().await.unwrap();
    
    // Verify task exists on device 2
    let synced_task = db2.get_task(&task.id).await.unwrap();
    assert_eq!(synced_task.title, "Test task");
}
```

### 9.3 E2E Tests

**Desktop (Playwright for Tauri):**
```typescript
import { test, expect } from '@playwright/test';

test('quick capture workflow', async ({ page }) => {
  await page.goto('tauri://localhost');
  
  // Trigger quick capture with hotkey
  await page.keyboard.press('CommandOrControl+Shift+Space');
  
  // Wait for overlay
  await expect(page.locator('.capture-overlay')).toBeVisible();
  
  // Type task
  await page.locator('.capture-input').fill('Test task tomorrow at 2pm');
  await page.keyboard.press('Enter');
  
  // Verify task appears in dashboard
  await expect(page.locator('.next-tasks')).toContainText('Test task');
});

test('complete task workflow', async ({ page }) => {
  await page.goto('tauri://localhost');
  
  // Click on a NEXT task
  await page.locator('.next-tasks .task-card').first().click();
  
  // Mark as NOW
  await page.locator('button:has-text("Start")').click();
  
  // Verify it moved to NOW section
  await expect(page.locator('.now-section')).toContainText('Test task');
  
  // Complete task
  await page.keyboard.press('Space');
  
  // Verify completion
  await expect(page.locator('.now-section')).toContainText('No active task');
});
```

**Mobile (Flutter Integration Tests):**
```dart
import 'package:flutter_test/flutter_test.dart';
import 'package:integration_test/integration_test.dart';
import 'package:taskflow/main.dart' as app;

void main() {
  IntegrationTestWidgetsFlutterBinding.ensureInitialized();
  
  testWidgets('quick add workflow', (WidgetTester tester) async {
    app.main();
    await tester.pumpAndSettle();
    
    // Tap quick add button
    await tester.tap(find.byIcon(Icons.add));
    await tester.pumpAndSettle();
    
    // Enter task title
    await tester.enterText(
      find.byType(TextField),
      'Test task'
    );
    await tester.tap(find.text('Save'));
    await tester.pumpAndSettle();
    
    // Verify task appears in list
    expect(find.text('Test task'), findsOneWidget);
  });
}
```

### 9.4 Performance Tests

**Load Testing:**
```rust
#[tokio::test]
async fn test_database_performance() {
    let db = setup_test_db().await;
    let start = Instant::now();
    
    // Create 1000 tasks
    for i in 0..1000 {
        db.create_task(&format!("Task {}", i), "work").await.unwrap();
    }
    
    let insert_duration = start.elapsed();
    assert!(insert_duration.as_millis() < 5000, "Bulk insert took too long");
    
    // Query tasks
    let query_start = Instant::now();
    let tasks = db.get_next_tasks(Some("work"), 100).await.unwrap();
    let query_duration = query_start.elapsed();
    
    assert_eq!(tasks.len(), 100);
    assert!(query_duration.as_millis() < 100, "Query took too long");
}
```

---

## 10. Development Environment

### 10.1 Prerequisites

**System Requirements:**
- **OS:** macOS 12+, Windows 10+, Ubuntu 20.04+
- **RAM:** 8GB minimum, 16GB recommended
- **Disk:** 5GB free space

**Development Tools:**
```bash
# Install Rust
curl --proto '=https' --tlsv1.2 -sSf https://sh.rustup.rs | sh

# Install Node.js (via nvm)
curl -o- https://raw.githubusercontent.com/nvm-sh/nvm/v0.39.0/install.sh | bash
nvm install 18
nvm use 18

# Install Tauri CLI
cargo install tauri-cli

# Install Flutter
# Follow: https://docs.flutter.dev/get-started/install

# Install Git
# Platform-specific installation
```

### 10.2 Repository Setup

```bash
# Clone repository
git clone https://github.com/brucembudi/taskflow.git
cd taskflow

# Install dependencies
npm install
cd mobile && flutter pub get && cd ..

# Setup development database
mkdir -p ~/.local/share/taskflow
sqlite3 ~/.local/share/taskflow/taskflow-dev.db < schema.sql

# Setup Git hooks
cp .githooks/pre-commit .git/hooks/
chmod +x .git/hooks/pre-commit
```

### 10.3 Running Development Servers

**Desktop:**
```bash
# Terminal 1: Frontend dev server
npm run dev

# Terminal 2: Tauri dev mode
npm run tauri dev

# Hot reload is enabled for both frontend and backend
```

**Mobile:**
```bash
cd mobile

# iOS Simulator
flutter run

# Android Emulator
flutter run

# Physical device
flutter run -d <device-id>
```

**MCP Server:**
```bash
cd taskflow-mcp

# Install in development mode
pip install -e .

# Test with Claude Code
# Add to claude_desktop_config.json:
{
  "mcpServers": {
    "taskflow": {
      "command": "python",
      "args": ["-m", "taskflow_mcp.server"]
    }
  }
}
```

### 10.4 Debugging

**Rust Backend:**
```bash
# Run with debug logging
RUST_LOG=debug npm run tauri dev

# Attach debugger (VS Code)
# launch.json
{
  "type": "lldb",
  "request": "launch",
  "name": "Tauri Debug",
  "cargo": {
    "args": [
      "build",
      "--manifest-path=./src-tauri/Cargo.toml"
    ]
  }
}
```

**React Frontend:**
```typescript
// Use React DevTools browser extension
// Enable source maps in vite.config.ts
export default defineConfig({
  build: {
    sourcemap: true,
  },
});
```

**Flutter:**
```dart
// Use Flutter DevTools
flutter pub global activate devtools
flutter pub global run devtools

// Debug in VS Code with launch.json
{
  "name": "Flutter Debug",
  "request": "launch",
  "type": "dart"
}
```

### 10.5 Code Quality Tools

**Linting:**
```bash
# Rust
cargo clippy -- -D warnings

# TypeScript
npm run lint

# Flutter
flutter analyze
```

**Formatting:**
```bash
# Rust
cargo fmt

# TypeScript
npm run format

# Flutter
flutter format lib/
```

**Testing:**
```bash
# Rust
cargo test

# TypeScript
npm run test

# Flutter
cd mobile && flutter test
```

---

## Appendices

### A. Database Schema Migrations

See Section 3.1 for full schema. Migrations managed via:
```rust
// migrations/001_initial_schema.sql
// migrations/002_add_shared_lists.sql
// etc.
```

### B. Environment Variables

```bash
# .env.development
DATABASE_URL=~/.local/share/taskflow/taskflow-dev.db
GIT_REMOTE_URL=git@github.com:brucembudi/taskflow-data.git
SYNC_INTERVAL_MINUTES=5
ENABLE_ANALYTICS=false
LOG_LEVEL=debug

# .env.production
DATABASE_URL=~/.local/share/taskflow/taskflow.db
GIT_REMOTE_URL=
SYNC_INTERVAL_MINUTES=15
ENABLE_ANALYTICS=false
LOG_LEVEL=info
```

### C. Configuration Files

**Tauri:** See Section 8.1  
**Flutter:** `pubspec.yaml`

**MCP Server:** `pyproject.toml`

### D. Deployment Checklist

- [ ] Run full test suite (unit + integration + E2E)
- [ ] Update version numbers (Cargo.toml, package.json, pubspec.yaml)
- [ ] Generate release notes
- [ ] Build all platform binaries
- [ ] Code sign macOS/Windows builds
- [ ] Upload to GitHub Releases
- [ ] Update documentation
- [ ] Announce release

---

**Next Steps:**
1. Review and approve this TDD
2. Set up development environment per Section 10
3. Begin Phase 1 implementation per PRD roadmap
4. Conduct weekly architecture reviews

**Document Approval:**
- [ ] Technical Lead: _________________
- [ ] Product Owner: _________________
- [ ] Security Review: _________________